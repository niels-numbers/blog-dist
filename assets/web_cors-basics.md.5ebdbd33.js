import{_ as e,c as s,o as t,a as o}from"./app.b76f1efb.js";const y=JSON.parse('{"title":"Web Security","description":"","frontmatter":{},"headers":[{"level":2,"title":"Same-Origin Policy (SOP)","slug":"same-origin-policy-sop","link":"#same-origin-policy-sop","children":[{"level":3,"title":"Get Requests are always allowed","slug":"get-requests-are-always-allowed","link":"#get-requests-are-always-allowed","children":[]},{"level":3,"title":"The CORS Protocol","slug":"the-cors-protocol","link":"#the-cors-protocol","children":[]}]},{"level":2,"title":"What CSRF Tokens Are and Why They Exist","slug":"what-csrf-tokens-are-and-why-they-exist","link":"#what-csrf-tokens-are-and-why-they-exist","children":[]},{"level":2,"title":"Why CSRF Tokens Are Still Needed (Even with CORS and SOP)","slug":"why-csrf-tokens-are-still-needed-even-with-cors-and-sop","link":"#why-csrf-tokens-are-still-needed-even-with-cors-and-sop","children":[{"level":3,"title":"Example: Attack via Email","slug":"example-attack-via-email","link":"#example-attack-via-email","children":[]},{"level":3,"title":"Why This Works","slug":"why-this-works","link":"#why-this-works","children":[]},{"level":3,"title":"Why CSRF Tokens Help","slug":"why-csrf-tokens-help","link":"#why-csrf-tokens-help","children":[]},{"level":3,"title":"Is checking origin of request enough?","slug":"is-checking-origin-of-request-enough","link":"#is-checking-origin-of-request-enough","children":[]}]},{"level":2,"title":"Problem with CSRF tokens","slug":"problem-with-csrf-tokens","link":"#problem-with-csrf-tokens","children":[]}],"relativePath":"web/cors-basics.md"}'),r={name:"web/cors-basics.md"},a=o(`<h1 id="web-security" tabindex="-1">Web Security <a class="header-anchor" href="#web-security" aria-hidden="true">#</a></h1><p>To build secure web apps, it&#39;s essential to understand how browsers handle cross-origin HTTP requests.</p><h2 id="same-origin-policy-sop" tabindex="-1">Same-Origin Policy (SOP) <a class="header-anchor" href="#same-origin-policy-sop" aria-hidden="true">#</a></h2><p>All browsers enforce the <strong><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noreferrer">same-origin policy</a></strong>, which blocks one origin from accessing resources on another origin. Origins can be:</p><ul><li>Domains (e.g. <a href="http://example.com" target="_blank" rel="noreferrer">example.com</a> \u2192 <a href="http://api.example.com" target="_blank" rel="noreferrer">api.example.com</a>)</li><li>Subdomain (e.g. <a href="http://app.example.com" target="_blank" rel="noreferrer">app.example.com</a> \u2192 <a href="http://dashboard.example.com" target="_blank" rel="noreferrer">dashboard.example.com</a>)</li><li>Port (e.g. <a href="http://example.com:80" target="_blank" rel="noreferrer">example.com:80</a> \u2192 <a href="http://example.com:3000" target="_blank" rel="noreferrer">example.com:3000</a>)</li><li>Protocol (e.g. http:// \u2192 https://)</li></ul><p>In simple terms: if two origins differ, direct access is <strong>forbidden by default</strong>.</p><p>However, there are many exceptions.</p><h3 id="get-requests-are-always-allowed" tabindex="-1">Get Requests are always allowed <a class="header-anchor" href="#get-requests-are-always-allowed" aria-hidden="true">#</a></h3><p>The same-origin policy does <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#cross-origin_network_access" target="_blank" rel="noreferrer">not restrict embed tags</a> like this:</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">img</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">https://dashboard.example.com/post-message/hello</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>Even if the image doesn&#39;t exist, the browser still sends the request directly to the server.<br> This is why <strong>state-changing endpoints must never use <code>GET</code></strong>, because embedded tags like <code>&lt;img&gt;</code> can trigger such requests without restrictions from any website.</p><p>Also, <strong>GET</strong> requests don&#39;t trigger a CORS preflight \u2014 more on that below.</p><blockquote><p>Exception: Some actions, like email confirmation or account invitation, are triggered by clicking a link in an email.<br> These usually use <code>GET</code> requests with a <strong>secure token</strong> in the URL: <code>https://yourapp.com/confirm/asdhakjfg1y91hiqsdjad</code>. Because the token is random and user-specific, this is considered safe \u2014 even though the request is a GET.</p></blockquote><h3 id="the-cors-protocol" tabindex="-1">The CORS Protocol <a class="header-anchor" href="#the-cors-protocol" aria-hidden="true">#</a></h3><p><strong><a href="https://fetch.spec.whatwg.org/#cors-protocol" target="_blank" rel="noreferrer">CORS</a> (Cross-Origin Resource Sharing)</strong> is a protocol that allows controlled communication between different origins.</p><p>As we\u2019ve seen, the Same-Origin Policy (SOP) blocks communication between different origins by default.<br> CORS provides a way for the server to explicitly allow such requests.</p><p>Before certain types of cross-origin requests are made, the browser must first ask the server for permission \u2014 this is known as a <strong>preflight request</strong>.</p><h4 id="preflight-requests" tabindex="-1">Preflight Requests <a class="header-anchor" href="#preflight-requests" aria-hidden="true">#</a></h4><p>For non-simple requests (e.g. <code>PUT</code>, <code>DELETE</code>, or requests with custom headers), the browser sends a <strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests" target="_blank" rel="noreferrer">CORS preflight request</a></strong> \u2014 an <code>OPTIONS</code> request with the <code>Origin</code> header.</p><p>The server replies with headers like <code>Access-Control-Allow-Origin</code> to approve or deny the request.</p><p>Only if the response explicitly allows the origin, the browser proceeds with the actual request.<br> See MDN: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests" target="_blank" rel="noreferrer">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests</a></p><p>Note: while many requests include the <code>Origin</code> header, <strong>not all are preflighted</strong>.<br> Only requests that are <em>not</em> &quot;simple&quot; (per the CORS spec) require a preflight.</p><h4 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-hidden="true">#</a></h4><p>If a server does not respond with <code>Access-Control-Allow-Origin</code>, the browser blocks the request \u2014 <strong>before it reaches the server logic</strong>.</p><p>This protects against cross-origin abuse in modern web apps.</p><h2 id="what-csrf-tokens-are-and-why-they-exist" tabindex="-1">What CSRF Tokens Are and Why They Exist <a class="header-anchor" href="#what-csrf-tokens-are-and-why-they-exist" aria-hidden="true">#</a></h2><p><strong>CSRF (Cross-Site Request Forgery)</strong> is a type of attack where a malicious website (or email) tricks a logged-in user into submitting a request to another site \u2014 typically without their knowledge.</p><p>Because browsers automatically attach cookies for the target site (e.g. session cookies), the request may look valid to the server \u2014 even though it was triggered from an external page.</p><p>A <strong>CSRF token</strong> is a secret value stored in the user\u2019s session and also embedded in the frontend (e.g. in a form or header).<br> When a state-changing request is made, the server checks that the token in the request matches the one in the session.<br> This ensures the request came from your frontend \u2014 not a malicious site.</p><p>CSRF protection is especially important for <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code> requests.</p><h2 id="why-csrf-tokens-are-still-needed-even-with-cors-and-sop" tabindex="-1">Why CSRF Tokens Are Still Needed (Even with CORS and SOP) <a class="header-anchor" href="#why-csrf-tokens-are-still-needed-even-with-cors-and-sop" aria-hidden="true">#</a></h2><p>You might think CORS or the Same-Origin Policy (SOP) would make CSRF tokens unnecessary \u2014 but that\u2019s not the case. Some <strong>simple requests</strong> (like form <code>POST</code>s with basic headers) <strong>do not trigger a preflight</strong>, and are allowed by default. Browsers allow simple <code>POST</code> requests from forms across origins by default (to preserve legacy behavior).</p><p>This is not an oversight, but a deliberate decision.<br> Form submissions existed before CORS and were already allowed to send data cross-origin.<br> The CORS spec assumes that servers were already protecting against CSRF, so it doesn\u2019t require a preflight for such requests. See also <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS#simple_requests" target="_blank" rel="noreferrer">here</a>:</p><blockquote><p>The motivation is that the element from HTML 4.0 (which predates cross-site XMLHttpRequest and fetch) can submit simple requests to any origin, so anyone writing a server must already be protecting against cross-site request forgery (CSRF). Under this assumption, the server doesn&#39;t have to opt-in (by responding to a preflight request) to receive any request that looks like a form submission, since the threat of CSRF is no worse than that of form submission. However, the server still must opt-in using Access-Control-Allow-Origin to share the response with the script.</p></blockquote><p>Unfortunately, a plain <code>&lt;form action=&quot;POST&quot;&gt;</code> creates a simple request!</p><p>Because of this, a malicious site can trigger a <strong>simple POST</strong> to your server, and the browser will include valid cookies \u2014 unless the server checks for a CSRF token.</p><p>In short: <strong>CORS doesn\u2019t block form submissions</strong>, and <strong>preflight is skipped</strong> \u2014 which is why <strong>CSRF tokens are still necessary</strong>.</p><h3 id="example-attack-via-email" tabindex="-1">Example: Attack via Email <a class="header-anchor" href="#example-attack-via-email" aria-hidden="true">#</a></h3><p>Imagine a user is logged in to <code>yourapp.com</code> in their browser.<br> They receive a malicious email that contains an HTML form:</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">form</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">action</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">https://yourapp.com/delete-account</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">method</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">POST</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">input</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">hidden</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">confirm</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">value</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">yes</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">submit</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Click here to win a prize!</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">form</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>If the user clicks the button while reading the email in a webmail client (e.g. Gmail), their browser will:</p><ol><li>Open a new tab to <code>yourapp.com</code>.</li><li>Send the <code>POST</code> request with their valid session cookies.</li><li>If your server doesn&#39;t check a CSRF token, it may accept and process the request \u2014 as if the user had clicked a button on your own site.</li></ol><h3 id="why-this-works" tabindex="-1">Why This Works <a class="header-anchor" href="#why-this-works" aria-hidden="true">#</a></h3><ul><li>The request is <strong>sent by the browser</strong> (so cookies are included).</li><li>It\u2019s a <strong>simple request</strong>, so <strong>no CORS preflight</strong> happens.</li><li><strong>SOP doesn\u2019t stop it</strong>, because it&#39;s a regular <code>POST</code> request \u2014 and those are allowed by default</li></ul><h3 id="why-csrf-tokens-help" tabindex="-1">Why CSRF Tokens Help <a class="header-anchor" href="#why-csrf-tokens-help" aria-hidden="true">#</a></h3><p>CSRF tokens fix this by requiring a secret value (only known to your frontend) in the request \u2014 either in a hidden form field or a header.<br> A malicious site or email <strong>cannot access this token</strong>, so the forged request will be rejected by your server.</p><h3 id="is-checking-origin-of-request-enough" tabindex="-1">Is checking origin of request enough? <a class="header-anchor" href="#is-checking-origin-of-request-enough" aria-hidden="true">#</a></h3><p>Since the <code>POST</code> request is sending the <code>Origin</code> along in the header and browser disallow modifying it, you might think: &quot;Can\u2019t I just check the <code>Origin</code> header?<br> In theory, yes \u2014 but in practice:</p><ul><li>The <code>Origin</code> header can be spoofed by scripts (e.g. in CLI tools).</li><li>Old or buggy browsers may send incorrect origin headers.</li><li>Browser plugins may modify or forge headers.</li></ul><p>From wikipedia:</p><blockquote><p>Various other techniques have been used or proposed for CSRF prevention historically. Verifying that the request&#39;s headers contain [...] HTTP Origin header. However, this is insecure \u2013 a combination of browser plugins and redirects can allow an attacker to provide custom HTTP headers on a request to any website, hence allowing a forged request</p></blockquote><p><strong>Use CSRF tokens</strong>, not just <code>Origin</code> checks \u2014 unless you have a very specific reason.</p><h2 id="problem-with-csrf-tokens" tabindex="-1">Problem with CSRF tokens <a class="header-anchor" href="#problem-with-csrf-tokens" aria-hidden="true">#</a></h2><p>For things like contact forms or long multi-step forms, CSRF tokens stored in the session can expire \u2014 especially if the user waits a long time before submitting. If a session expires, the user loses everything \u2014 a terrible UX.</p><p>Instead, you can generate a <strong>form-specific token</strong> when the form is first shown, and:</p><ul><li>Store it in the database or a Redis cache (e.g. keyed by token string or user ID)</li><li>Include the token in the form (e.g. as a hidden input)</li><li>Validate the token on submission and delete it after use</li></ul><p>Alternatives:</p><ul><li>Use reCAPTCHA v3 for contact forms (no user interaction) and/or throtteling.</li><li>Extend session lifetime (but not scalable approach).</li><li>Use <strong>cookie-stored sessions</strong> that persist on the client side (and don\u2019t expire easily).</li></ul>`,58),n=[a];function i(l,c,h,p,d,u){return t(),s("div",null,n)}const m=e(r,[["render",i]]);export{y as __pageData,m as default};
